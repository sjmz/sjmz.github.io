---
layout: post
title: "union explained with an ip address"
date: 2025-09-04
categories: CAT1 CAT2
---

Not a long ago while reading kernel code I stumbled across something like this:

```c
struct slab {
	unsigned long __page_flags;

	struct kmem_cache *slab_cache;
	union {
		struct {
			union {
				struct list_head slab_list;
#ifdef CONFIG_SLUB_CPU_PARTIAL
				struct {
					struct slab *next;
					int slabs;	/* Nr of slabs left */
				};
#endif
			};

	[...]
};
```

without going into the details of what this is, one thing captured my eyes: those 'union'.
I'vee been programming in C for quite a long time and I was aware of the existence of such keyword, but never went to use it nor tried to understand its purpose.

I quickly googled, watched a video and all explanations were something like: "union defines multiple variables which access the same memory".

After experimenting I realized that there is a missing subtelty in the definition which really explain unions.

Let's say you're working on the network stack and that you need to encode ip addresses.
An ip address is a simple: a.b.c.d where a,b,c,d (call it digits) can assume a value in the range [0, 255]. The dots are just for formatting.

Now, how can you represent an address like '127.0.0.1' ?
Well, remember that each digit must be positive and cannot exceed 255.
Meaning that it can be represented with 1 byte.
So, a complete ip address is just 4 bytes of information.

In C, an int variable usually stores 4 bytes, so it is a good candidate for encoding our ip address.
We can set the most significant byte to 127 and the least significant one to 1.

```c
int ip = 0;

ip = 127 << 24;
ip = ip | 1;
```

Or even

```c
int ip = 0x7f000001;
```

This code is not very readable because it assumes that you already know that 0x7f000001 is the binary encoding of 127.0.0.1
Moreover, a single digit operation involves masking/shifting/flipping all the 32 bits.

We want to access and modify the individual byte of those 32 bits.
We can rely on pointers by doing.

```c
int ip = 0;
char * b = &ip;

*b = 1;
*(b + 3) = 127;
```

I write 127 to the last byte because of the little-endian convention.
This works too but union provides a more elegant solution.

In C, a union is defined as:

```c
union name {
	type1 f1;
	type2 f2;
	type3 f3;
	...
};
```

When you see something like

```c
union MyUnion{
	int a;
	char b;
	char c[4];
};

union MyUnion U;

U.a = ...
U.b = ...
U.c[2] = ...
```

You are first treating U as if it were an integer variable, then as a char and finally as an array of chars.
U is the block of memory and a, b, c the type of access.
The size of this block corresponds to that of the largest-in-size field defined, in this case 4 bytes.

Coming back to the original problem, we can do like this:
```c
union ip_addr{
	int raw_ip;
	char oct[4];	
};

union ip_addr ip;

ip.oct[0] = 1;
ip.oct[1] = 0;
ip.oct[2] = 0;
ip.oct[3] = 127;
```

In this case, space is reserved for 4 bytes and we defined a type of access as an integer variable or as a char array.

We can go extreme and access the individual bytes with a name, like this:
```c
struct s_oct {
	char oct4;
	char oct3;
	char oct2;
	char oct1;
}

union ip_addr{
	int raw_ip;
	char oct[4];	
	struct s_oct octs;
};

union ip_addr ip;

ip.octs.oct1 = 1;
ip.octs.oct2 = 0;
ip.octs.oct3 = 0;
ip.octs.oct4 = 127;
```

The following is the complete source of this example:
```c
#include <stdio.h>

void print_ip(int raw){
	char oct1 = (raw >> 24) & 0xff;
	char oct2 = (raw >> 16) & 0xff;
	char oct3 = (raw >> 8) & 0xff;
	char oct4 = raw & 0xff;

	printf("ip: %d.%d.%d.%d\n", oct1, oct2, oct3, oct4);
}

struct s_oct {
	char oct4;
	char oct3;
	char oct2;
	char oct1;
};

union ip_addr {
	int raw;
	char oct[4];
	struct s_oct octs;
};

int main(int argc, char ** argv[]){

	union ip_addr ip;
	char * b = ip.oct;

	ip.raw = 0x7f000001;

	print_ip(ip.raw);

	ip.oct[3] = 127;
	ip.oct[2] = 0;
	ip.oct[1] = 0;
	ip.oct[0] = 1;

	print_ip(ip.raw);

	ip.octs.oct1 = 127;
	ip.octs.oct2 = 0;
	ip.octs.oct3 = 0;
	ip.octs.oct4 = 1;

	print_ip(ip.raw);

	*b = 1;
	*(b + 3) = 127;

	print_ip(ip.raw);

	return 0;
}
```
