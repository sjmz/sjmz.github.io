---
layout: post
title: "hlist_for_each_entry, offsetof, padding and CVE-2016-4486"
date: 2025-09-14
---

I was reading some netlink code, specifically, I was trying to understand construction of responses due to a RTM_GETLINK request.
I suggest you reading [this]({% post_url 2025-09-12-netlink_nonsql %}) blogpost where netlink sockets and messages are introduced and explored so you can get a feeling for this.
As an attempt to understand the netlink codebase better for then writing about it, I strumbled across different interesting ideas that I want to share.

# **// rtnl_register**

In the last blogpost we made an ip clone which, by sending a proper netlink packet, was able to extract information about network interfaces such as lo and wlp1s0.

`netlink_kernel_create` is the function in charge of instantiating a kernel netlink socket.
The one specific for the routing subsystem is created inside the `rtnetlink_net_init` function.
`rtnetlink_net_init`, among other things, sets a callback that serves as a handler for the messages sent to the rtnetlink socket.
This handler is the `rtnetlink_rcv` function.

In reality, `rtnetlink_rcv` doesn't directly treat the specific packets, but it dispatches other more specific handlers.
`rtnl_register` is the function that associates a packet with the specific handler to call.

Inside net/core/rtnetlink.c, `rtnl_register` is called multiple times with different arguments.
```c
void __init rtnetlink_init(void)
{
	[...]

	rtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink, rtnl_dump_ifinfo, 0);
	rtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, NULL, 0);
	rtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, NULL, 0);
	rtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, NULL, 0);

	rtnl_register(PF_UNSPEC, RTM_GETADDR, NULL, rtnl_dump_all, 0);
	rtnl_register(PF_UNSPEC, RTM_GETROUTE, NULL, rtnl_dump_all, 0);

	[...]
}
```

`rtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink, rtnl_dump_ifinfo, 0)` is the call that sets the specific handlers for RTM_GETLINK requests.
The one of interest for now is the `rtnl_dump_ifinfo`, which is called upon receiving a request with the NLM_F_DUMP flag set.

Inside it, there is this code path:
```c
	[...]

	for (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {
		idx = 0;
		head = &tgt_net->dev_index_head[h];
		hlist_for_each_entry(dev, head, index_hlist) {
		
			[...]

			err = rtnl_fill_ifinfo(skb, dev, net,
					       RTM_NEWLINK,
					       NETLINK_CB(cb->skb).portid,
					       nlh->nlmsg_seq, 0, flags,
					       ext_filter_mask, 0, NULL, 0,
					       netnsid, GFP_KERNEL);
			[...]
cont:
			idx++;
		}
	}

	[...]
```

What it does in practice is loop over the network devices and construct the various response packets.
`rtnl_fill_ifinfo` can be an object of discussion for another time.
What I found intruiging is that `hlist_for_each_entry` macro.

# **// hlist_for_each_entry**

`hlist_for_each_entry`, defined in include/linux/list.h is the following.

```c
/**
 * hlist_for_each_entry	- iterate over list of given type
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry(pos, head, member)				\
	for (pos = hlist_entry_safe((head)->first, typeof(*(pos)), member);\
	     pos;							\
	     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))
```

Cryptic as I expected, but in reality it simply expands as a for loop.
The advantage of using such a macro is that you don't have to write the loop manually, which in many cases becomes difficult to read overtime.

As the description says:
* **pos** (`struct net_device *dev`) is the loop variable.
* **head** (`struct hlist_head *head`) is the start of this 'list' of network devices
* **member** (`struct hlist_node index_hlist`) ... no words to describe it for now ...

Let's split the for loop in its main three components:
* **Initialization**: `pos = hlist_entry_safe((head)->first, typeof(*(pos)), member)` There is some preprocessor trickery here that makes `dev` point to the first item in a list of `struct net_device`(s)
* **Termination condition**: simply set to `pos` (or `dev` after expansion), which is equivalent to `pos != NULL`
* **Increment**:  `pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member)` This makes `dev` point to the next `struct net_device` in the list

Apart from the simple termination condition of 'until `dev` is different from NULL', you can see the use of `hlist_entry_safe`.

# **// hlist_entry_safe**

```c
// from include/linux/list.h

#define hlist_entry_safe(ptr, type, member) \
	({ typeof(ptr) ____ptr = (ptr); \
	   ____ptr ? hlist_entry(____ptr, type, member) : NULL; \
	})
```


First, a copy of `ptr` is created with `typeof(ptr) ____ptr = (ptr)`.
`typeof(ptr)` is a compiler 'directive' that expands as the type of the variable `ptr`.
Then it checks if `___ptr` is not NULL, if it does the for loop exits as `pos` would have become NULL itself.

`hlist_entry_safe` is expanded as `hlist_entry`:

```c
// still from include/linux/list.h
#define hlist_entry(ptr, type, member) container_of(ptr,type,member)
```

# **// container_of**

`container_of`, defined in include/linux/kernel.h, is a very handy and useful macro.
Its arguments are:
* **ptr** : pointer to the field of a struct
* **type** : the type of this struct
* **member** : the name of the field that is pointed by `ptr`

This is the scenario and what `container_of` does.

<p align="center">
  <img src="{{site.baseurl}}/assets/images/containerof.png" width="600">
</p>

Coming back to that for loop expansion:
```c
	for (pos = hlist_entry_safe((head)->first, typeof(*(pos)), member);\
	     pos;							\
	     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))
```

We can now make the following statements:
* Initially, `pos` is set to point to the structure that **holds/contains** the field pointed by `(head)->first`. The type/name of this structure is defined as the type of the object pointed by `pos` (`struct net_device`)
* **head-\>first** is the address of the field called '**member**' inside a '**typeof(*\(pos))**' struct.
* The next structure in the list is the one that holds/contains the field pointed by `(pos)->member.next`

Based on this we can imagine the following organization:

![]({{site.baseurl}}/assets/images/hlist_entry1.png)

The implementation of `container_of` is quite singular and it deserves some attention. I have deliberately removed a line of code just to show the core calculation.
```c
#define container_of(ptr, type, member) ({                              \
        void *__mptr = (void *)(ptr);                                   \
        ((type *)(__mptr - offsetof(type, member))); })
```

It subtracts from the `ptr` field pointer the location of the '`member`' field within the structure '`type`'.
In other words, it decrements that pointer by the number of bytes that are present between the starting of the structure and the field to which we have access.
The resulting address is interpreted as a pointer to a struct of type '`type`'.

The problem is now finding the displacement/distance of the '`member`' field from the beginning of the '`type`' struct.

# **// offsetof**

The `offsetof` macro, defined in include/linux/stddef.h, given a `type` and `member` arguments, calculates the displacement of the field called '`member`' from the '`type`' structure.
This is the way it does it:

```c
#define offsetof(TYPE, MEMBER)  ((size_t)&((TYPE *)0)->MEMBER)
```

Construct this gradually starting from the most inner expressions:
* `(TYPE *)0`: this might be tricky at first glance, but is simple in reality. It says "build a pointer to a variable of type '`TYPE`' and set it to 0". Since a pointer is a variable that contains the address of another variable, here we assume that the '`TYPE`' structure is located at address 0
* `&((TYPE *)0)->MEMBER`: get the address of the field called '`MEMBER`' 
* `(size_t)...` : convert the obtained address to an unsigned type

<p align="center">
  <img src="{{site.baseurl}}/assets/images/offsetof.png" width="500">
</p>

The diagram above shows that by 'placing' a fictitious structure of any type at location 0, the address of a field coincide with its displacement from the starting of the structure.

# **// sizeof(char) = 1**

Having discovered this pointer trick I went to replicate it.
I considered this simple structure:

```c
struct dummy {
	int a;
	char b;
	int c;
	int d;
};
```

I know that an integer occupies four bytes, whereas a char just one.
So I would say that the offset of `c` is 5 bytes from the start of the structure.
Let's verify:

```c
struct dummy * p = NULL;

printf("offsetof a: %ld \n", (size_t) &(p->a));
printf("offsetof b: %ld \n", (size_t) &(p->b));
printf("offsetof c: %ld \n", (size_t) &(p->c));
printf("offsetof d: %ld \n", (size_t) &(p->d));
```

```text
offsetof a: 0 
offsetof b: 4 
offsetof c: 8 
offsetof d: 12
```

Not what I expected since I count 5 bytes of occupied space before `c`.
In practice it means that there are three additional bytes between `b` and `c`.
Let's experiment a bit.

This loop traverses the structure at the byte level and writes a known value such as '0xff':
```c
struct dummy d;
char * mem = (char *) &d;

memset(&d, 0, 16);

for(int i = 0; i < 16; i++){
        mem[i] = 0xff;
        printf("[%d] c = %d\n", i, d.c);
}
```
```text
[0] c = 0
[1] c = 0
[2] c = 0
[3] c = 0
[4] c = 0
[5] c = 0
[6] c = 0
[7] c = 0
[8] c = 255
[9] c = 65535
[10] c = 16777215
[11] c = -1
[12] c = -1
[13] c = -1
[14] c = -1
[15] c = -1
```

This proves that `c` is really displaced by eight bytes and not by five.
This is what happens:

![]({{site.baseurl}}/assets/images/sizeof.png)

The three extra bytes, marked in red, are placed between `b` and `c`.
Figuring out this made me realize why I didn't understand CVE-2016-4486 as well as its fix.

Also, the diagram above clearly shows the result of memory access under the 'litte endian' model.
Writing to the first byte where `c` is stored results in the setting of its LEAST significat byte.

# **// CVE-2016-4486**

Look at [this](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5f8e44741f9f216e33736ea4ec65ca9ac03036e6) commit:
```text
net: fix infoleak in rtnetlink
The stack object “map” has a total size of 32 bytes. Its last 4
bytes are padding generated by compiler. These padding bytes are
not initialized and sent out via “nla_put”.
```
and the relative patch:
```diff
 static int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev)
 {
-	struct rtnl_link_ifmap map = {
-		.mem_start   = dev->mem_start,
-		.mem_end     = dev->mem_end,
-		.base_addr   = dev->base_addr,
-		.irq         = dev->irq,
-		.dma         = dev->dma,
-		.port        = dev->if_port,
-	};
+	struct rtnl_link_ifmap map;
+
+	memset(&map, 0, sizeof(map));
+	map.mem_start   = dev->mem_start;
+	map.mem_end     = dev->mem_end;
+	map.base_addr   = dev->base_addr;
+	map.irq         = dev->irq;
+	map.dma         = dev->dma;
+	map.port        = dev->if_port;
+
```

The following is the definition of `struct rtnl_link_ifmap` in include/uapi/linux/if_link.h with the corresponding field sizes:

```c
struct rtnl_link_ifmap {
        __u64   mem_start; // 8 bytes
        __u64   mem_end;   // 8 bytes
        __u64   base_addr; // 8 bytes
        __u16   irq;	   // 2 bytes
        __u8    dma;       // 1 byte
        __u8    port;      // 1 byte
};
```

The 'theoretical' size of `struct rtnl_link_ifmap` is 28 bytes.
Usually, struct sizes are aligned to be a multiple of the size of the largest occupying field.
For this reason, 4 bytes of padding are added to `struct rtnl_link_ifmap` so that its size becomes a multiple of 8 bytes.
Note that it is incorrect to say 'added to `struct rtnl_link_ifmap`'.
**What is enlarged is the block of memory that hosts the structure, not the structure itself**.

What is the problem with the original initialization of `struct rtnl_link_ifmap map`?

Consider this example:

```c
#include <stdio.h>
#include <string.h>

struct dummy {
        int a;
        char b;
        int c;
        int d;
};

void print_mem(char * mem, int len){
        for(int i = 0; i < len; i++)
                printf("mem[%d] = %d\n", i, mem[i]);
}

void f(){
        char buf[100];
        memset(buf, 'A', 100);
}

void g(){
        struct dummy d = {
                .a = 0,
                .b = 0,
                .c = 0,
                .d = 0
        };

        print_mem((char *)&d, 16);
}

int main(){

        f();
        g();

        return 0;
}
```

The function `f` simply declares an array of 100 bytes and fills its content with the character 'A'.
The function `g` declares a variable of type `struct dummy` and initializes its content to 0, then prints every byte of memory occupied by it. 
The result:
```text
mem[0] = 0
mem[1] = 0
mem[2] = 0
mem[3] = 0
mem[4] = 0
mem[5] = 65
mem[6] = 65
mem[7] = 65
mem[8] = 0
mem[9] = 0
mem[10] = 0
mem[11] = 0
mem[12] = 0
mem[13] = 0
mem[14] = 0
mem[15] = 0
```

First, a stack frame is dedicated for the `f` function and part of it is used by `buf`.
This frame is then removed when `f` exits.
When `g` starts a new stack frame is allocated for it, but in the same place that was previously occupied by `f`.

As seen before, `struct dummy` is padded so that its size is a multiple of 4 bytes.
The problem is that an initialization syntax such as `d = {.a = 0, .b = 0, .c = 0, .d = 0}` doesn't 'touch' the padding bytes that might be introduced.
Since `f`, when finishing, doesn't clear the space used by `buf`, the scenario is the following:

![]({{site.baseurl}}/assets/images/stackundisc.png)

This might seem harmful, but imagine sensitive information left in memory such as kernel data structures or specific pointers.

The fix to CVE-2016-4486 is a simple `memset(&map, 0, sizeof(map))`.
This clears out ALL the space occupied by `map`, both its fields and additional 'unreachable' padding.
First, `memset` writes at a byte level, which means that it has access to those in-between hidden bytes.
Secondly, the patch itself is effective because of the use of `sizeof`.
`sizeof` calculates the space occupied by variables including padding bytes.

This also demonstrates that struct/pointer access such as: `struct.field` or `p->field` is actually a layer of abstraction when comes to data access.
Padding bytes are hidden and alignment is transparent to the programmer.

It is possible to disable this 'feature' by declaring the `dummy` structure as:

```c
struct __attribute__((packed)) dummy {
	int a;
	char b;
	int c;
	int d;
};

```

This addition makes that 'offsetof clone' output this:

```text
offsetof a: 0 
offsetof b: 4 
offsetof c: 5 
offsetof d: 9
```

I hope you found this interesting.
