---
layout: post
title: "hlist_for_each_entry, offsetof, padding and CVE-2016-4486"
date: 2025-09-14
---

I was reading some netlink code, specifically, I was trying to understand construction of responses due to a RTM_GETLINK request.
I suggest you reading [this]({% post_url 2025-09-12-netlink_nonsql %}) blogpost where netlink sockets and messages are introduced and explored so you can get a feeling for this.
As an attempt to understand the netlink codebase better for then writing about it, I strumbled across different interesting ideas that I want to share.

# **// rtnl_register**

In the last blogpost we made an ip clone which, by sending a proper netlink packet, was able to extract information about network interfaces such as lo and wlp1s0.

`netlink_kernel_create` is the function in charge of instantiating a kernel netlink socket.
The one specific for the routing subsystem is created inside the `rtnetlink_net_init` function.
Among other things, it sets a callback that serves as a handler for the messages sent to this socket.
This handler is the `rtnetlink_rcv` function.

In reality, `rtnetlink_rcv` doesn't treat the specific packets, but it dispatches specific handlers based on request tipology and the flags associated with it.

`rtnl_register` does exactly this.
Inside net/core/rtnetlink.c, `rtnl_register` is called multiple times with different arguments.
```c
void __init rtnetlink_init(void)
{
	[...]

	rtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink, rtnl_dump_ifinfo, 0);
	rtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, NULL, 0);
	rtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, NULL, 0);
	rtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, NULL, 0);

	rtnl_register(PF_UNSPEC, RTM_GETADDR, NULL, rtnl_dump_all, 0);
	rtnl_register(PF_UNSPEC, RTM_GETROUTE, NULL, rtnl_dump_all, 0);

	[...]
}
```

`rtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink, rtnl_dump_ifinfo, 0)` is the call that sets the specific handlers for RTM_GETLINK requests.
The one of interest for now is the `rtnl_dump_ifinfo`, which is called upon receiving a request with the NLM_F_DUMP flag set.

Inside it, there is this code path:
```c
	[...]

	for (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {
		idx = 0;
		head = &tgt_net->dev_index_head[h];
		hlist_for_each_entry(dev, head, index_hlist) {
		
			[...]

			err = rtnl_fill_ifinfo(skb, dev, net,
					       RTM_NEWLINK,
					       NETLINK_CB(cb->skb).portid,
					       nlh->nlmsg_seq, 0, flags,
					       ext_filter_mask, 0, NULL, 0,
					       netnsid, GFP_KERNEL);
			[...]
cont:
			idx++;
		}
	}

	[...]
```

What it does in practice is loop over the network devices and construct the various response packets.
`rtnl_fill_ifinfo` can be an object of discussion for another time.
What I found intruiging is that `hlist_for_each_entry` macro.

# **// hlist_for_each_entry**

`hlist_for_each_entry`, defined in include/linux/list.h is the following.
I suggest opening the actual code file as I won't repaste the whole snippet again.

```c
/**
 * hlist_for_each_entry	- iterate over list of given type
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry(pos, head, member)				\
	for (pos = hlist_entry_safe((head)->first, typeof(*(pos)), member);\
	     pos;							\
	     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))

#define hlist_entry_safe(ptr, type, member) \
	({ typeof(ptr) ____ptr = (ptr); \
	   ____ptr ? hlist_entry(____ptr, type, member) : NULL; \
	})

#define hlist_entry(ptr, type, member) container_of(ptr,type,member)
```

Cryptic as I expect it, but in reality it simply expands as a for loop.
The advantage of using this is that you don't have to define the loop manually, which in many cases is difficult to read.

As the description says:
* **pos** / `struct net_device *dev` is the loop variable.
* **head** / `struct hlist_head *head` is the start of this 'list' of network devices
* **member** / `struct hlist_node index_hlist` ... no words to describe it for now ...

Let's split the for loop in its main three components:
* **Initialization**: `pos = hlist_entry_safe((head)->first, typeof(*(pos)), member)` There is some preprocessor trickery here that makes `dev` point to the start of a list of `struct net_device`(s)
* **Termination condition**: simply set to `pos` (or `dev` after expansion), which is equivalent to `pos != NULL`
* **Increment**:  `pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member)` This makes `dev` point to the next `struct net_device`

Apart from the simple termination condition of 'until `dev` is different from NULL', you can see the use of `hlist_entry_safe`.

# **// hlist_entry_safe**

First, a copy of `ptr` is created with `typeof(ptr) ____ptr = (ptr)`.
`typeof(ptr)` is a compiler 'directive' that expands as the type of the variable `ptr`.
Then it checks if `___ptr` is not NULL, if it does the for loop exits as `pos` would have become NULL itself.

Finally, `hlist_entry_safe` is expanded in an elegant definition as simple as `container_of(ptr, type, member)`.

# **// container_of**

`container_of` is a very handy and useful macro.
Its arguments are:
* **ptr** : pointer to the field of a struct
* **type** : the type of this struct
* **member** : the name of the field that is pointed by `ptr`

This is the scenario and what `container_of` does.

![]({{site.baseurl}}/assets/images/containerof.png)

Coming back to that for loop expansion:
```c
	for (pos = hlist_entry_safe((head)->first, typeof(*(pos)), member);\
	     pos;							\
	     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))
```

We can now make the following statements:
* Initially, `pos` is set to point to the structure that **holds/contains** `head->first`. The type/name of this structure is defined by the type of the pointer `pos`
* **head-\>first** is the address of the field inside a **'typeof(*\(pos))'** struct that is called **'member'**.
* The next structure in the list is the one that holds/contains `(pos)->member.next`

Based on this we can imagine the following organization:

![]({{site.baseurl}}/assets/images/hlist_entry1.png)

The implementation of `container_of` is quite singular and it deserves some attention. I have deliberately removed a line of code just to show the core calculation.
```c
#define container_of(ptr, type, member) ({                              \
        void *__mptr = (void *)(ptr);                                   \
        ((type *)(__mptr - offsetof(type, member))); })
```

It subtracts from the known address the offset of the field within the structure.
In other words, it decrements that pointer by the number of bytes that are present between the starting of the structure and the field to which we have access.
This resulting address is interpreted as a pointer to a struct of type '`type`'.

The problem is now finding the displacement/distance of `'member'` from `struct 'type'`.

# **// offsetof**

The `offsetof` macro, given a `type` and `member arguments`, calculates the displacement of the field called `'member'` from `struct 'type'`.
And the way it does this is even more singular:

```c
#define offsetof(TYPE, MEMBER)  ((size_t)&((TYPE *)0)->MEMBER)
```

Construct this gradually starting from the most inner expressions:
* `(TYPE *)0`: this might be tricky at first glance, but is simple in reality. It says "build a pointer to a variable of type `'TYPE'` and set it to 0". Since a pointer is a variable that contains the address of another variable, here we assume that `struct 'TYPE'` is located at address '0'
* `&((TYPE *)0)->MEMBER`: access to the field called `'MEMBER'` and get its address using the `&` operator
* `(size_t)...` : convert the obtained address to an unsigned type

This is the scenario:
![]({{site.baseurl}}/assets/images/offsetof.png)

This means that by placing a fictitious structure of any type at location '0', the address of a field coincide to its displacement from the starting of the structure.

