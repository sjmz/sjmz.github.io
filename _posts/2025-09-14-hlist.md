---
layout: post
title: "hlist_for_each_entry, offsetof, padding and CVE-2016-4486"
date: 2025-09-14
---

I was reading some netlink code, specifically, I was trying to understand construction of responses due to a RTM_GETLINK request.
I suggest you reading [this]({% post_url 2025-09-12-netlink_nonsql %}) blogpost where netlink sockets and messages are introduced and explored so you can get a feeling for this.
As an attempt to understand the netlink codebase better for then writing about it, I strumbled across different interesting ideas that I want to share.

# **// rtnl_register**

In the last blogpost we made an ip clone which, by sending a proper netlink packet, was able to extract information about network interfaces such as lo and wlp1s0.

`netlink_kernel_create` is the function in charge of instantiating a kernel netlink socket.
The one specific for the routing subsystem is created inside the `rtnetlink_net_init` function.
Among other things, it sets a callback that serves as a handler for the messages sent to this socket.
This handler is the `rtnetlink_rcv` function.

In reality, `rtnetlink_rcv` doesn't treat the specific packets, but it dispatches specific handlers based on request tipology and the flags associated with it.

`rtnl_register` does exactly this.
Inside net/core/rtnetlink.c, `rtnl_register` is called multiple times with different arguments.
```c
void __init rtnetlink_init(void)
{
	[...]

	rtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink, rtnl_dump_ifinfo, 0);
	rtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, NULL, 0);
	rtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, NULL, 0);
	rtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, NULL, 0);

	rtnl_register(PF_UNSPEC, RTM_GETADDR, NULL, rtnl_dump_all, 0);
	rtnl_register(PF_UNSPEC, RTM_GETROUTE, NULL, rtnl_dump_all, 0);

	[...]
}
```

`rtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink, rtnl_dump_ifinfo, 0)` is the call that sets the specific handlers for RTM_GETLINK requests.
The one of interest for now is the `rtnl_dump_ifinfo`, which is called upon receiving a request with the NLM_F_DUMP flag set.

Inside it, there is this code path:
```c
	[...]

	for (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {
		idx = 0;
		head = &tgt_net->dev_index_head[h];
		hlist_for_each_entry(dev, head, index_hlist) {
		
			[...]

			err = rtnl_fill_ifinfo(skb, dev, net,
					       RTM_NEWLINK,
					       NETLINK_CB(cb->skb).portid,
					       nlh->nlmsg_seq, 0, flags,
					       ext_filter_mask, 0, NULL, 0,
					       netnsid, GFP_KERNEL);
			[...]
cont:
			idx++;
		}
	}

	[...]
```

What it does in practice is loop over the network devices and construct the various response packets.
`rtnl_fill_ifinfo` can be an object of discussion for another time.
What I found intruiging is that `hlist_for_each_entry` macro.

# **// hlist_for_each_entry**

`hlist_for_each_entry`, defined in include/linux/list.h is the following.
I suggest opening the actual code file as I won't repaste the whole snippet again.

```c
/**
 * hlist_for_each_entry	- iterate over list of given type
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry(pos, head, member)				\
	for (pos = hlist_entry_safe((head)->first, typeof(*(pos)), member);\
	     pos;							\
	     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))

#define hlist_entry_safe(ptr, type, member) \
	({ typeof(ptr) ____ptr = (ptr); \
	   ____ptr ? hlist_entry(____ptr, type, member) : NULL; \
	})

#define hlist_entry(ptr, type, member) container_of(ptr,type,member)
```

Cryptic as I expect it, but in reality it simply expands as a for loop.
The advantage of using this is that you don't have to define the loop manually, which in many cases is difficult to read.

As the description says:
* **pos** / `struct net_device *dev` is the loop variable.
* **head** / `struct hlist_head *head` is the start of this 'list' of network devices
* **member** / `struct hlist_node index_hlist` ... no words to describe it for now ...

Let's split the for loop in its main three components:
* **Initialization**: `pos = hlist_entry_safe((head)->first, typeof(*(pos)), member)` There is some preprocessor trickery here that makes `dev` point to the start of a list of `struct net_device`(s)
* **Termination condition**: simply set to `pos` (or `dev` after expansion), which is equivalent to `pos != NULL`
* **Increment**:  `pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member)` This makes `dev` point to the next `struct net_device`

Apart from the simple termination condition of 'until `dev` is different from NULL', you can see the use of `hlist_entry_safe`.

# **// hlist_entry_safe**

First, a copy of `ptr` is created with `typeof(ptr) ____ptr = (ptr)`.
`typeof(ptr)` is a compiler 'directive' that expands as the type of the variable `ptr`.
Then it checks if `___ptr` is not NULL, if it does the for loop exits as `pos` would have become NULL itself.

Finally, `hlist_entry_safe` is expanded in an elegant definition as simple as `container_of(ptr, type, member)`.

# **// container_of**

`container_of`, defined in include/linux/kernel.h, is a very handy and useful macro.
Its arguments are:
* **ptr** : pointer to the field of a struct
* **type** : the type of this struct
* **member** : the name of the field that is pointed by `ptr`

This is the scenario and what `container_of` does.

![]({{site.baseurl}}/assets/images/containerof.png)

Coming back to that for loop expansion:
```c
	for (pos = hlist_entry_safe((head)->first, typeof(*(pos)), member);\
	     pos;							\
	     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))
```

We can now make the following statements:
* Initially, `pos` is set to point to the structure that **holds/contains** `head->first`. The type/name of this structure is defined by the type of the pointer `pos`
* **head-\>first** is the address of the field inside a **'typeof(*\(pos))'** struct that is called **'member'**.
* The next structure in the list is the one that holds/contains `(pos)->member.next`

Based on this we can imagine the following organization:

![]({{site.baseurl}}/assets/images/hlist_entry1.png)

The implementation of `container_of` is quite singular and it deserves some attention. I have deliberately removed a line of code just to show the core calculation.
```c
#define container_of(ptr, type, member) ({                              \
        void *__mptr = (void *)(ptr);                                   \
        ((type *)(__mptr - offsetof(type, member))); })
```

It subtracts from the known address the offset of the field within the structure.
In other words, it decrements that pointer by the number of bytes that are present between the starting of the structure and the field to which we have access.
This resulting address is interpreted as a pointer to a struct of type '`type`'.

The problem is now finding the displacement/distance of `'member'` from `struct 'type'`.

# **// offsetof**

The `offsetof` macro, defined in include/linux/stddef.h, given a `type` and `member arguments`, calculates the displacement of the field called `'member'` from `struct 'type'`.
And the way it does this is even more singular:

```c
#define offsetof(TYPE, MEMBER)  ((size_t)&((TYPE *)0)->MEMBER)
```

Construct this gradually starting from the most inner expressions:
* `(TYPE *)0`: this might be tricky at first glance, but is simple in reality. It says "build a pointer to a variable of type `'TYPE'` and set it to 0". Since a pointer is a variable that contains the address of another variable, here we assume that `struct 'TYPE'` is located at address '0'
* `&((TYPE *)0)->MEMBER`: access to the field called `'MEMBER'` and get its address using the `&` operator
* `(size_t)...` : convert the obtained address to an unsigned type

This is the scenario:
![]({{site.baseurl}}/assets/images/offsetof.png)

This means that by placing a fictitious structure of any type at location '0', the address of a field coincide with its displacement from the starting of the structure.

# **// sizeof(char) = 1**

Having discovered this pointer trick I went to replicate it.
I considered this simple structure:

```c
struct dummy {
	int a;
	char b;
	int c;
	int d;
};
```

I know that an integer occupies four bytes, whereas a char just one.
So I might say that the offset of `c` is 5 bytes from the start of the structure.
Let's verify:

```c
struct dummy * p = NULL;

printf("offsetof a: %ld \n", (size_t) &(p->a));
printf("offsetof b: %ld \n", (size_t) &(p->b));
printf("offsetof c: %ld \n", (size_t) &(p->c));
printf("offsetof d: %ld \n", (size_t) &(p->d));
```

```text
offsetof a: 0 
offsetof b: 4 
offsetof c: 8 
offsetof d: 12
```

Not what I expected since I count 5 bytes of occupied space before `c`.
In practice it means that there are three additional bytes between `b` and `c`.
Let's experiment a bit.

This loop traverses the structure at the byte level and writes a known value such as '0xff':
```c
struct dummy d;
char * b = (char *) &d;

memset(&d, 0, 16);

for(int i = 0; i < 16; i++){
        b[i] = 0xff;
        printf("[%d] c = %d\n", i, d.c);
}
```
```text
[0] c = 0
[1] c = 0
[2] c = 0
[3] c = 0
[4] c = 0
[5] c = 0
[6] c = 0
[7] c = 0
[8] c = 255
[9] c = 65535
[10] c = 16777215
[11] c = -1
[12] c = -1
[13] c = -1
[14] c = -1
[15] c = -1
```

This proves that `c` is really displaced by eight bytes and not by five.
This is what happens:

![]({{site.baseurl}}/assets/images/sizeof.png)

The three extra bytes, marked in red, are placed between `b` and `c`.
Figuring out this made me realize why I didn't understand CVE-2016-4486 as well as its fix.

# **// CVE-2016-4486**

Look at [this](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5f8e44741f9f216e33736ea4ec65ca9ac03036e6) commit:
```text
net: fix infoleak in rtnetlink
The stack object “map” has a total size of 32 bytes. Its last 4
bytes are padding generated by compiler. These padding bytes are
not initialized and sent out via “nla_put”.
```
and the relative patch:
```diff
 static int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev)
 {
-	struct rtnl_link_ifmap map = {
-		.mem_start   = dev->mem_start,
-		.mem_end     = dev->mem_end,
-		.base_addr   = dev->base_addr,
-		.irq         = dev->irq,
-		.dma         = dev->dma,
-		.port        = dev->if_port,
-	};
+	struct rtnl_link_ifmap map;
+
+	memset(&map, 0, sizeof(map));
+	map.mem_start   = dev->mem_start;
+	map.mem_end     = dev->mem_end;
+	map.base_addr   = dev->base_addr;
+	map.irq         = dev->irq;
+	map.dma         = dev->dma;
+	map.port        = dev->if_port;
+
```

This is the definition of `struct rtnl_link_ifmap` in include/uapi/linux/if_link.h with the corresponding field sizes:

```c
struct rtnl_link_ifmap {
        __u64   mem_start; // 8 bytes
        __u64   mem_end;   // 8 bytes
        __u64   base_addr; // 8 bytes
        __u16   irq;	   // 2 bytes
        __u8    dma;       // 1 byte
        __u8    port;      // 1 byte
};
```

The 'theoretical' size of `struct rtnl_link_ifmap` is 28 bytes.
But usually, struct sizes are aligned to be a multiple of the size of the largest occupying field.
For this reason, 4 bytes are added as padding to `struct rtnl_link_ifmap` so that its size becomes a multiple of 8 bytes.

What is the problem with the original initialization of `struct rtnl_link_ifmap`?

Consider this example:

```c
#include <stdio.h>
#include <string.h>

struct dummy {
        int a;
        char b;
        int c;
        int d;
};

void print_mem(char * mem, int len){
        for(int i = 0; i < len; i++)
                printf("mem[%d] = %d\n", i, mem[i]);
}

void f(){
        char buf[100];
        memset(buf, 'A', 100);
}

void g(){
        struct dummy d = {
                .a = 0,
                .b = 0,
                .c = 0,
                .d = 0
        };

        print_mem((char *)&d, 16);
}

int main(){

        f();
        g();

        return 0;
}
```

The function `f` simply declares an array of 100 bytes and fills its content with the character 'A'.
The function `g` declares a variable of type `struct dummy` and initializes its content to 0, then prints every byte of memory occupied by it. 
The result:
```text
mem[0] = 0
mem[1] = 0
mem[2] = 0
mem[3] = 0
mem[4] = 0
mem[5] = 65
mem[6] = 65
mem[7] = 65
mem[8] = 0
mem[9] = 0
mem[10] = 0
mem[11] = 0
mem[12] = 0
mem[13] = 0
mem[14] = 0
mem[15] = 0
```

First, a stack frame is dedicated for the `f` function and part of it is used by `buf`.
This frame is then removed when `f` exits.
When `g` starts a new stack frame is allocated for it, but in the same place that previously by `g`.

As seen before, `struct dummy` is padded so that its size is a multiple of 4 bytes.
The problem is that an initialization syntax such as `d = {.a = 0, .b = 0, .c = 0, .d = 0}` doesn't touch the padding bytes that might be introduced.
Since `f`, when finishing, doesn't clear the space used by `buf`, the scenario is the following:

![]({{site.baseurl}}/assets/images/stackundisc.png)

This might seem harmful, but imagine sensitive information left in memory such as kernel data structures or specific pointers.

The fix to CVE-2016-4486 is a simple `memset(&map, 0, sizeof(map))`.
This clears out ALL the space occupied by `map`, both its fields and additional 'unreachable' padding.
First, `memset` writes at a byte level, which means that it has access to those in-between hidden bytes.
Secondly, the patch itself is effective because of the use of `sizeof`.
`sizeof` calculates the space occupied by variables, and it also includes padding bytes.

This also demonstrates that struct/pointer access such as: `struct.field` or `p->field` is actually a layer of abstraction when comes to data access.
Padding bytes are hidden and alignment is transparent to the programmer.

It is actually possible to disable this 'feature' by declaring the `dummy` structureas:

```c
struct __attribute__((packed)) dummy {
	int a;
	char b;
	int c;
	int d;
};

```

This addition makes that 'offsetof clone' output this:

```text
offsetof a: 0 
offsetof b: 4 
offsetof c: 5 
offsetof d: 9
```

I hope you found this interesting.
