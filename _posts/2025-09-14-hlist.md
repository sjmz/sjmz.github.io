---
layout: post
title: "hlist_for_each_entry, offsetof, padding and CVE-2016-4486"
date: 2025-09-14
---

I was reading some netlink code, specifically, I was trying to understand construction of responses due to a RTM_GETLINK request.
I suggest you reading [this]({% post_url 2025-09-12-netlink_nonsql %}) blogpost where netlink sockets and messages are introduced and explored so you can get a feeling for this.
As an attempt to understand the netlink codebase better for then writing about it, I strumbled across different interesting ideas that I want to share.

# **// rtnl_register**

In the last blogpost we made an ip clone which, by sending a proper netlink packet, was able to extract information about network interfaces such as lo and wlp1s0.

`netlink_kernel_create` is the function in charge of instantiating a kernel netlink socket.
The one specific for the routing subsystem is created inside the `rtnetlink_net_init` function.
Among other things, it sets a callback that serves as a handler for the messages sent to this socket.
This handler is the `rtnetlink_rcv` function.

In reality, `rtnetlink_rcv` doesn't treat the specific packets, but it dispatches specific handlers based on request tipology and the flags associated with it.

`rtnl_register` does exactly this.
Inside net/core/rtnetlink.c, `rtnl_register` is called multiple times with different arguments.
```c
void __init rtnetlink_init(void)
{
	[...]

	rtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink, rtnl_dump_ifinfo, 0);
	rtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, NULL, 0);
	rtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, NULL, 0);
	rtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, NULL, 0);

	rtnl_register(PF_UNSPEC, RTM_GETADDR, NULL, rtnl_dump_all, 0);
	rtnl_register(PF_UNSPEC, RTM_GETROUTE, NULL, rtnl_dump_all, 0);

	[...]
}
```

`rtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink, rtnl_dump_ifinfo, 0)` is the call that sets the specific handlers for RTM_GETLINK requests.
The one of interest for now is the `rtnl_dump_ifinfo`, which is called upon receiving a request with the NLM_F_DUMP flag set.

Inside it, there is this code path:
```c
	[...]

	for (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {
		idx = 0;
		head = &tgt_net->dev_index_head[h];
		hlist_for_each_entry(dev, head, index_hlist) {
		
			[...]

			err = rtnl_fill_ifinfo(skb, dev, net,
					       RTM_NEWLINK,
					       NETLINK_CB(cb->skb).portid,
					       nlh->nlmsg_seq, 0, flags,
					       ext_filter_mask, 0, NULL, 0,
					       netnsid, GFP_KERNEL);
			[...]
cont:
			idx++;
		}
	}

	[...]
```

What it does in practice is loop over the network devices and construct the various response packets.
`rtnl_fill_ifinfo` can be an object of discussion for another time.
What I found intruiging is that `hlist_for_each_entry` macro.

`hlist_for_each_entry`, defined in include/linux/list.h is this:
```c
/**
 * hlist_for_each_entry	- iterate over list of given type
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry(pos, head, member)				\
	for (pos = hlist_entry_safe((head)->first, typeof(*(pos)), member);\
	     pos;							\
	     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))

#define hlist_entry_safe(ptr, type, member) \
	({ typeof(ptr) ____ptr = (ptr); \
	   ____ptr ? hlist_entry(____ptr, type, member) : NULL; \
	})

#define hlist_entry(ptr, type, member) container_of(ptr,type,member)
```

Cryptic as I expect it, but in reality it simply expands as a for loop.
The advantage of using this is that you don't have to define the loop manually, which in many cases can be tedious to read.

As the description says:
* **pos** is the loop variable, which in our case is `struct net_device * dev`
* **head** is the start of this 'list' of network devices
* **member**... what is 'member'?

Let's split the for loop in its main three components:
* **Initialization**: `pos = hlist_entry_safe((head)->first, typeof(*(pos)), member)` There is some preprocessor trickery here that makes `dev` point to the start of a list of `struct net_device`(s)
* **Termination condition**: simply set to `pos` (or `dev` after expansion), which is equivalent to `pos != NULL`
* **Increment**:  `pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member)` This makes `dev` point to the next `struct net_device`

Apart from the simple termination condition of 'until `dev` is different from NULL', you can see the use of `hlist_entry_safe`.

